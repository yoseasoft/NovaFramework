# Actor 对象创建与资源管理指南

## 一、概述
Actor是游戏框架中的重要概念，它继承自`CActor`，而`CActor`又继承自`CEntity`。本指南将详细介绍如何创建Actor对象并有效管理其资源加载和卸载。

---

## 二、创建Actor对象

### 2.1 通过名称创建Actor
```csharp
//创建Actor对象
Actor playerActor = GameApi.CreateActor("Player") as Actor;
//销毁Actor对象
GameApi.DestroyActor("Player");
```
**适用场景**：运行时根据配置动态创建不同类型的Actor

---

### 2.2 通过泛型创建Actor
```csharp
//创建Actor对象
Actor playerActor = GameApi.CreateActor<Player>();
//销毁Actor对象
GameApi.DestroyActor<Player>();
```
**优势**：类型安全且性能最佳

---

### 2.3 通过Type创建Actor
```csharp
//创建Actor对象
Actor playerActor = GameApi.CreateActor(typeof(Player)) as Actor;
//销毁Actor对象
GameAPi.DestroyActor(typeof(Player));
```
**适用场景**：运行时动态确定类型的场景

---

### 2.4通过Bean配置创建对象
![文件 text](../images/bean_image.png)
```csharp
//创建Actor对象
Actor game_actor = GameEngine.ApplicationContext.CreateBean("game_actor") as Actor;
//销毁Actor对象
GameEngine.ApplicationContext.ReleaseBean(game_actor);
```

---

## 三、销毁Actor对象
| 方法                  | 立即销毁 | 延迟销毁 | 适用场景               |
|-----------------------|--------|--------|----------------------|
| `DestroyActor(playerActor)` | 是     | 否     | 立即回收资源          |
| `DestroyActor("Player")` | 是     | 否     | 通过名称销毁          |
| `DestroyActor<Player>()` | 是     | 否     | 通过泛型销毁          |
| `DestroyActor(typeof(Player))` | 是     | 否     | 通过Type销毁          |

---


## 四、同步实例化方法（Instantiate）

### 1.1 重载1：指定位置和旋转（最常用）
**功能**：在指定世界坐标位置和旋转角度实例化资源对象  
**语法**：
```csharp
public T Instantiate<T>(
    string name, 
    string url, 
    Vector3 position, 
    Quaternion rotation
) where T : UnityEngine.Object
```

**参数说明**:

| 参数名      | 类型          | 描述                          |
|-------------|---------------|-------------------------------|
| name        | string        | 资源名称（唯一标识）          |
| url         | string        | 资源路径（Prefab路径）        |
| position    | Vector3       | 实例化位置（世界坐标）        |
| rotation    | Quaternion    | 实例化旋转（四元数）          |

**案例代码**：
```csharp
// 场景：在坐标 (2, 0, 30) 处实例化玩家模型
void SyncInstantiate_PositionRotation()  
{
    Actor playerActor = GameApi.CreateActor<Actor>();
    
    GameObject playerModel = playerActor.Instantiate<GameObject>(
        name: "playerModel",
        url: "Assets/_Resources/Model/jianshi/prefab/001.prefab",
        position: new Vector3(2, 0, 30f),
        rotation: Quaternion.identity
    );

    Debug.Log($"同步实例化成功：{playerModel?.name}");
}
```

---

### 1.2 重载2：指定位置、旋转和父对象
**功能**：将实例化对象挂载到父对象下  
**语法**：
```csharp
public T Instantiate<T>(
    string name, 
    string url, 
    Vector3 position, 
    Quaternion rotation, 
    Transform parent
) where T : UnityEngine.Object
```

**案例代码**：
```csharp
// 场景：在玩家脚下实例化武器模型
void SyncInstantiate_WithParent()  
{
    Transform playerRoot = playerActor.transform;
    
    GameObject weapon = playerActor.Instantiate<GameObject>(
        name: "weapon_001",
        url: "Assets/_Resources/Weapon/Sword.prefab",
        position: new Vector3(0, 1, 0),
        rotation: Quaternion.Euler(0, 90, 0),
        parent: playerRoot
    );
}
```

---

### 1.3 重载3：仅指定父对象
**功能**：使用资源默认位置和旋转  
**语法**：
```csharp
public T Instantiate<T>(
    string name, 
    string url, 
    Transform parent
) where T : UnityEngine.Object
```

**案例代码**：
```csharp
// 场景：在UI面板下实例化血条
void SyncInstantiate_DefaultTransform()  
{
    Transform uiPanel = uiActor.transform.Find("HealthPanel");
    
    GameObject healthBar = uiActor.Instantiate<GameObject>(
        name: "health_bar_prefab",
        url: "Assets/_Resources/UI/HealthBar.prefab",
        parent: uiPanel
    );
}
```

---

## 五、异步实例化方法（InstantiateAsync）
**特点**：通过UniTask实现非阻塞加载，适合大资源

### 2.1 重载1：指定位置和旋转
```csharp
public async UniTask<T> InstantiateAsync<T>(
    string name, 
    string url, 
    Vector3 position, 
    Quaternion rotation
) where T : UnityEngine.Object
```

**案例代码**：
```csharp
async void AsyncInstantiate_PositionRotation()  
{
    GameObject castle = await sceneActor.InstantiateAsync<GameObject>(
        name: "castle_big",
        url: "Assets/_Resources/Map/Castle.prefab",
        position: new Vector3(100, 0, 200),
        rotation: Quaternion.identity
    );
}
```

---

### 2.2 重载2：指定位置、旋转和父对象
```csharp
public async UniTask<T> InstantiateAsync<T>(
    string name, 
    string url, 
    Vector3 position, 
    Quaternion rotation, 
    Transform parent
) where T : UnityEngine.Object
```

**案例代码**：
```csharp
async void AsyncInstantiate_WithParent()  
{
    GameObject enemy = await enemyManager.InstantiateAsync<GameObject>(
        name: "goblin_001",
        url: "Assets/_Resources/Enemy/Goblin.prefab",
        position: new Vector3(-5, 0, 10),
        rotation: Quaternion.Euler(0, 180, 0),
        parent: enemiesParent
    );
}
```

---

### 2.3 重载3：仅指定父对象
**功能**：使用资源默认位置和旋转  
**语法**：
```csharp
public async UniTask<T> InstantiateAsync<T>(
    string name, 
    string url, 
    Transform parent
) where T : UnityEngine.Object
```

**案例代码**：
```csharp
// 场景：在UI面板下实例化货币栏
 async void SyncInstantiate_DefaultTransform()  
{
    Transform uiPanel = uiActor.transform.Find("MoneyPanel");
    
    GameObject moneyBar = await  uiActor.Instantiate<GameObject>(
        name: "momey_bar_prefab",
        url: "Assets/_Resources/UI/MoneyBar.prefab",
        parent: uiPanel
    );
}
```

---

## 六、完整综合案例
```csharp
async void FullCase_PlayerSetup()  
{
    // 1. 创建玩家 Actor
    Actor playerActor = GameApi.CreateActor<Actor>();
    
    try {
        // 2. 同步实例化主角模型
        GameObject playerModel = await playerActor.Instantiate<GameObject>(
            name: "player_main_model",
            url: "Assets/_Resources/Model/jianshi/prefab/001.prefab"
        );

        // 3. 异步加载武器
        GameObject sword = await playerActor.InstantiateAsync<GameObject>(
            name: "weapon_sword_001",
            url: "Assets/_Resources/Weapon/LongSword.prefab",
            parent: playerModel.transform
        );

        // 4. 资源管理
        playerActor.UnloadAsset("old_player_model_v1");
    }
    catch (Exception e) {
        Debug.LogError($"初始化失败：{e.Message}");
    }
}
```

---

## 七、注意事项
1. **资源名称唯一性**：同一Entity内名称必须唯一
2. **异步方法规范**：必须配合`await`使用
3. **对象销毁方式**：销毁对象后，底层框架会自动卸载资源
4. **路径校验**：确保资源路径存在且大小写匹配

---
                        


