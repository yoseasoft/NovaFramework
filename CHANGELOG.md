## 修改日志
此项目的所有显著更改都将记录在此文件中。  

格式基于[保持更改日志](https://keepachangelog.com/en/1.0.0/)  
该项目遵循[语义版本控制](https://semver.org/spec/v2.0.0.html)  

### 1.0.10
修复在调度过程中动态添加的组件不能正常执行`Update`的问题（若实体对象原本没有`Update`流程的情况下）；  
重构实体管理句柄扩展为泛型，为其实现类`CScene`，`CActor`及`CView`等提供通用的实体缓存队列及访问接口；  

### 1.0.9
修复实体对象的 BeanName 在`Awake`之后才设置，导致前面的节点中关于 Bean 绑定的组件无法正确注册问题；  
修复继承自`CSceneClass`，`CActorClass`和`CViewClass`的标签无法正确解析问题；  
修复实体对象在`Awake`期间注册新组件实例将导致链表访问异常问题；  
修复属性标签绑定时因`List.Contains`方法错误判定导致只能存在一个实例的问题；  
新增切面回调函数在解析时支持对抽象基类的检测及绑定流程；  

### 1.0.8
修复事件、消息和输入的转发时对回调函数的封装流程；  
针对普通函数在构筑委托代理是不指定目标对象实例，而在动态调用时传入的封装方式，在执行时，会触发异常：  
`ArgumentException: Delegate to an instance method cannot have null 'this'.`  
这个问题的核心原因是‌运行时环境差异导致的委托调用机制变化‌。  
在Unity编辑器环境下，委托的调用验证相对宽松，允许在DynamicInvoke时动态指定this对象。  
但打包成Windows可执行文件后，运行在.NET Framework或.NET Core的严格模式下，  
系统会强制检查委托创建时的_target字段，确保实例方法的委托在创建时就绑定了正确的对象引用。  
因此，针对普通函数，`Bean`对象会在每个实例的内部都构筑一个委托句柄的实例，  
只有静态函数（包括扩展类型）才会使用全局通用委托句柄来进行调度。

### 1.0.7
增加`applicationContext`配置入口，通过该配置管理整个应用的上下文信息；  
当前支持在该模块中对`HotModule`及`Bean`对象进行配置管理；  
同时梳理业务启动流程，拆分了`ContextLoader`、`AssemblyLoader`和`ConfigLoader`三个步骤；

### 1.0.5
新增`StreamBuf`模块，用于支持流式协议加载及解析；  
目前部分项目采用数据流自定义接口解析的方式进行网络消息同步，因此通过动态模块进行支持；

### 1.0.4
新增`HotModule`机制，通过配置动态加载模块；  
同时将`Protobuf`，`FairyGui`，`UGui`剥离为独立模块，具备动态加载的能力；  
调整`GameWorld`的初始化流程，确保在模块被正确加载后，再进行类符号解析操作；

### 1.0.3
新增`UGui`视图类型的框架支持，可以通过统一的视图操作，驱动不同类型的视图对象；
- 通过配置默认视图类型，来创建默认类型的视图对象；
- 通过在定义视图类时，填入当前类所属的视图类型，来创建特殊视图对象；

### 1.0.2
将`IExecutable`循环机制补充到调度分发流程中；  
新增视图对象的分组规则，通过分组设计来管理视图的层级关系；  
新增`Notice`机制，并增加对应的特性管理及加载流程；  
新增视图对象的`Resume/Reveal`及`Pause/Cover`配置接口；

### 1.0.1
增加了一个内置的分层状态机模型，试图尝试用该模型来管理视图的动画机制；  
对框架进行了一些优化，如：
- 输入、事件和消息在实体对象中的绑定，不再对每个对象实例进行委托函数的创建，而是在底层缓存中创建一个实例，然后每个对象实例均引用它；
- 整理符号对象的结构，梳理共用字段的定义；
- 重载流程重定义，调整热重载需要销毁的数据，归纳整理到`Reload`流程中；

### 1.0.0
提交基础引擎版本，其中涵盖的版本内容及功能包括：
- 通过总入口进行统一调度，然后对各个子模块进行分发，包括各种管理器及实体对象；
- 构建底层API与管理层之间的事务通知机制，实现引擎层与管理层间的解耦；
- 实体对象生命周期统一调度管理，包括创建、初始化、更新、销毁等；
- 构建视图对象管理机制，并实现视图对象创建、初始化、更新、销毁等；
- 对资源访问模块进行封装，提供资源访问接口，并实现资源加载、缓存、释放等操作；
- 提供网络通信，设备输入，文件IO等系统接口的高级封装，并实现框架内部的调度分发管理；
- 构建实体对象输入、事件和消息的分发机制，并实现输入、事件和消息的注册及注销；
